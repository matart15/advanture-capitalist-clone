### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Asset {
  business: Business!
  businessId: Int!
  count: Int!
  id: Int!
  lastUseStartedAt: DateTime
  level: Int!
  levelMaxCount: Int!
  managedAuto: Boolean!
  price: Int!
  profit: Int!
  profitDuration: Int!
  totalCount: Int!
  user: User!
  userId: Int!
}

input AssetFilter {
  every: AssetWhereInput
  none: AssetWhereInput
  some: AssetWhereInput
}

input AssetOrderByInput {
  businessId: OrderByArg
  count: OrderByArg
  id: OrderByArg
  lastUseStartedAt: OrderByArg
  level: OrderByArg
  levelMaxCount: OrderByArg
  managedAuto: OrderByArg
  price: OrderByArg
  profit: OrderByArg
  profitDuration: OrderByArg
  totalCount: OrderByArg
  userId: OrderByArg
}

input AssetWhereInput {
  AND: [AssetWhereInput!]
  business: BusinessWhereInput
  businessId: IntFilter
  count: IntFilter
  id: IntFilter
  lastUseStartedAt: NullableDateTimeFilter
  level: IntFilter
  levelMaxCount: IntFilter
  managedAuto: BooleanFilter
  NOT: [AssetWhereInput!]
  OR: [AssetWhereInput!]
  price: IntFilter
  profit: IntFilter
  profitDuration: IntFilter
  totalCount: IntFilter
  user: UserWhereInput
  userId: IntFilter
}

input AssetWhereUniqueInput {
  businessId: Int
  id: Int
}

input BooleanFilter {
  equals: Boolean
  not: Boolean
}

type Business {
  assets(skip: Int): [Asset!]!
  basePrice: Int!
  id: Int!
  managerName: String!
  managerPrice: Int!
  name: String!
}

input BusinessOrderByInput {
  baseLevelMaxCount: OrderByArg
  basePrice: OrderByArg
  baseProfit: OrderByArg
  baseProfitDuration: OrderByArg
  id: OrderByArg
  managerName: OrderByArg
  managerPrice: OrderByArg
  name: OrderByArg
}

input BusinessWhereInput {
  AND: [BusinessWhereInput!]
  assets: AssetFilter
  baseLevelMaxCount: IntFilter
  basePrice: IntFilter
  baseProfit: IntFilter
  baseProfitDuration: IntFilter
  id: IntFilter
  managerName: StringFilter
  managerPrice: IntFilter
  name: StringFilter
  NOT: [BusinessWhereInput!]
  OR: [BusinessWhereInput!]
}

input BusinessWhereUniqueInput {
  id: Int
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: Int
  notIn: [Int!]
}

type Mutation {
  addBusiness(assetId: Int!, count: Int!, userId: Int!): Asset!
  buyBusiness(businessId: Int!, userId: Int!): Asset!
  buyManager(assetId: Int!, userId: Int!): Asset!
  collectAssetProfit(assetId: Int!, userId: Int!): Asset!
  collectAutoManagedAssedProfit(assetId: Int!, userId: Int!): Asset!
  register: Asset!
  startUsingAsset(assetId: Int!, userId: Int!): Asset!
}

input NullableDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTime
  notIn: [DateTime!]
}

enum OrderByArg {
  asc
  desc
}

type Query {
  asset(where: AssetWhereUniqueInput!): Asset
  assets(orderBy: AssetOrderByInput, skip: Int, where: AssetWhereInput): [Asset!]!
  business(where: BusinessWhereUniqueInput!): Business
  businesses(orderBy: BusinessOrderByInput, skip: Int, where: BusinessWhereInput): [Business!]!
  user(where: UserWhereUniqueInput!): User
  users(orderBy: UserOrderByInput, skip: Int, where: UserWhereInput): [User!]!
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: String
  notIn: [String!]
  startsWith: String
}

type User {
  assets(skip: Int): [Asset!]!
  id: Int!
  lastUpdated: DateTime!
  money: Int!
}

input UserOrderByInput {
  id: OrderByArg
  lastUpdated: OrderByArg
  money: OrderByArg
}

input UserWhereInput {
  AND: [UserWhereInput!]
  assets: AssetFilter
  id: IntFilter
  lastUpdated: DateTimeFilter
  money: IntFilter
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: Int
}
